# 关于割草机控制逻辑的简要说明

## 一、下位机

### 1.电机控制信号的确定

示波器测得 P W M 周期为 14 ms   为71.4286 Hz

所以有：

```c++
#ifndef PWM_CONTROL__H
#define PWM_CONTROL__H


#include <Arduino.h>
/* =============================== */
#include "driver/mcpwm.h"


// 定义MCPWM单元和定时器
#define MCPWM_UNIT  MCPWM_UNIT_0
#define MCPWM_TIMER MCPWM_TIMER_0

const float wheel_distance_ = 0.76;

class Pwm_control
{
public:

    Pwm_control(); // 构造函数
    ~Pwm_control(); // 析构函数
    void  botPwm_init() const;
    float mapFloat(int x, float in_min, float in_max, float out_min, float out_max);
    float getDutyCycle(int speed);
    void  set_WheelSpeed(double linear_speed, double angular_speed);
    // 定义GPIO引脚
    const int r_pwmPin = 4;                   // 用于MCPWM的GPIO，右轮
    const int l_pwmPin = 5;                   // 用于MCPWM的GPIO，左轮
    // 设置的PWM频率
    const float pwmFrequency = 71.4286;       // 71.4286 Hz
    // 占空比控制区间
    const float dutyCycleMinCCW = 8.857;    // 逆时针最小占空比
    const float dutyCycleMaxCCW = 10.639;   // 逆时针最大占空比
    const float dutyCycleMinCW  = 10.639;   // 顺时针最小占空比
    const float dutyCycleMaxCW  = 12.429;   // 顺时针最大占空比
private:
};



#endif /* PWM_CONTROL__H */
```

### 2、电机占空比的精细控制，

此处代码定义了在不同区间段的 电机转向逻辑，值得注意的是，10.639 是测量中间值，当占空比小于 此中间值时，占空比越小，电机逆时针转速越快，当占空比大于此中间值时，占空比越大，电机顺时针转速越快。关于 P W M 控制 采用了 arduino框架 内置的 mcpwm库。

```c++
/**
 * 此函数初始化MCPWM的每个gpio信号
 * 参数: mcpwm_num-设置MCPWM单元 (0-1) io_signal-设置MCPWM信号，每个MCPWM单元有6个输出 (MCPWMXA，MCPWMXB) 和9个输入 (同步_X，故障_X, CAP_X) 'X' 是计时器_num(0-2) gpio_num-设置此为MCPWM配置gpio，如果要使用gpio16，gpio_num = 16
 * 返回: ESP_OK成功-ESP_ERR_INVALID_ARG参数错误
 * 备注: 此函数一次初始化一个gpio。
 * 
 */
void  Pwm_control::botPwm_init() const
{
    // 初始化两个电机的引脚
    mcpwm_gpio_init(MCPWM_UNIT, MCPWM0A, this->l_pwmPin);
    mcpwm_gpio_init(MCPWM_UNIT, MCPWM0B, this->r_pwmPin);
    pwmConfig.frequency = this->pwmFrequency;     // 初始化MCPWM配置
    pwmConfig.cmpr_a = 0;
    pwmConfig.cmpr_b = 0;
    pwmConfig.counter_mode = MCPWM_UP_COUNTER;
    pwmConfig.duty_mode = MCPWM_DUTY_MODE_0;
    mcpwm_init(MCPWM_UNIT, MCPWM_TIMER, &pwmConfig);  // 设置并启动MCPWM
}
```

将两个占空比区间各分250个分辨率，初始假定割草机最大行进速度为1 m/s

```c++
// 映射浮点数的函数
//   (x/250) * (10.639-8.857)    相当于将占空比分出 250 份中取 x 份

float Pwm_control::mapFloat(int x, float in_min, float in_max, float out_min, float out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
```

### 3、电机转向逻辑匹配

下面根据上位机给出的线速度与角速度输出对应的差速指令

```c++
/**
 * @参数   线速度，角速度
 * @输出   无
  */
void Pwm_control::set_WheelSpeed(const double linear_speed, const double angular_speed)
{
    // 计算左轮的转速 out_wheelL_speed，公式为 线速度 减去 角速度乘以轮距的一半
    double out_wheelL_speed =
        linear_speed - (angular_speed * wheel_distance_) / 2.0;
    // 计算右轮的转速 out_wheelR_speed，公式为 线速度 加上 角速度乘以轮距的一半。
    double out_wheelR_speed =
        linear_speed + (angular_speed * wheel_distance_) / 2.0;

    // 这里不做最大速度限制，但原则上说下位机控制板应该监控轮速并且在轮速异常时与上位机确认，给出一个绝对控制 IO 作为安全保障
    if (linear_speed == 0 && angular_speed == 0)
    {
        double dutyCycle1 = this->getDutyCycle(250);
        if (dutyCycle1 >= 0) {
            // 设置占空比
            mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, dutyCycle1);
            mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, MCPWM_DUTY_MODE_0);
        }
        double dutyCycle2 = this->getDutyCycle(250);
        if (dutyCycle2 >= 0) {
            // 设置占空比
            mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, dutyCycle2);
            mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, MCPWM_DUTY_MODE_0);
        }
        return;
    }

    // 这里判断 输出轮速对应 250 个分辨率中的位置
    // 考虑做四舍五入处理  round(value)

    int speed1 = 0;
    float dutyCycle1 = 0.0;
    int speed2 = 0;
    float dutyCycle2 = 0.0;
    // 左轮
    if (out_wheelL_speed > 0) {                 // 左轮顺时针
        speed1 = round(250 - (out_wheelL_speed * 250));
        if (speed1 <= 0)
            speed1 = 0;

        dutyCycle1 = this->getDutyCycle(speed1);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, dutyCycle1);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, MCPWM_DUTY_MODE_0);
    } else if (out_wheelL_speed < 0) {          // 左轮逆时针
        speed1 = round(250 + std::abs(out_wheelL_speed * 250));
        if (speed1 >= 500)
            speed1 = 500;

        dutyCycle1 = this->getDutyCycle(speed1);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, dutyCycle1);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, MCPWM_DUTY_MODE_0);
    }

    if (out_wheelR_speed > 0) {                 // 右轮顺时针
        speed2 = round(250 + (out_wheelR_speed * 250));
        if (speed2 >= 500)
            speed2 = 500;

        dutyCycle2 = this->getDutyCycle(speed2);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, dutyCycle2);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, MCPWM_DUTY_MODE_0);
    } else if (out_wheelR_speed < 0) {          // 右轮逆时针
        speed2 = round(250 - std::abs(out_wheelR_speed * 250));
        if (speed2 <= 0)
            speed2 = 0;
        dutyCycle2 = this->getDutyCycle(speed2);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, dutyCycle2);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, MCPWM_DUTY_MODE_0);
    }

}

```

## 二、上位机

### 1、创建动作消息接口和RTK设备串口信息接收接口

动作消息接口.action

```apl
# 请求数据
float64 goal_theta
float64 goal_latitude
float64 goal_longitude
---
# 最终响应
float64 x
float64 y
float64 theta
---
# 连续反馈
float64 distance
```

RTK数据消息接口.msg

```apl
# Rtgps.msg
float64 heading
float64 latitude
float64 longitude
```

### 2、利用 ROS 2 串口库对 rtk设备信息进行处理并发布对应的 **[R T K 数据消息接口.msg]()**

着重强调的是 rtk设备输出的 是 正北 顺时针的 0 ～360 的方位角信息，而对应 UTM 坐标系时，我需要 以一个  std::atan2() 来处理目标点与车辆当前的相对角度

std::atan2() 生成的是一个弧度制 以 正东为 0度， 逆时针为正 0 ～ 180,瞬时针为 0 ～ -180，因此要做对应的角度转换来保证指令逻辑的匹配

```c++
#include "gphpr_pub/rtk_msg.hpp"
#include <deque>
#include <string>

// 假设有一个结构来存储需要的数据
struct GpsData {
    double latitude;
    double longitude;
};

my_exer_interfaces::msg::Rtgps rtk_msg;

std::deque<GpsData> gngga_data;
std::deque<GpsData> gnggah_data;


SerialPortNode::SerialPortNode(): 
    Node("serial_port_node"), 
    m_port_name("/dev/ttyUSB0"), 
    m_baud_rate(115200) {
        // 串口初始化
    try {
        sp_.setPort(m_port_name);
        sp_.setBaudrate(m_baud_rate);
        serial::Timeout timeout = serial::Timeout::simpleTimeout(1000);
        sp_.setTimeout(timeout);
        sp_.open();
        sp_.flush();
        std::cout << "Serial port opened successfully..." << std::endl;
    } catch (const serial::IOException &e) {
        std::cerr << "Failed to open the serial port." << std::endl;
        return;
    }

    m_rtk_pub = this->create_publisher<my_exer_interfaces::msg::Rtgps>("rtkms", rclcpp::SensorDataQoS());
    // 创建定时器，每10ms调用一次readSerial方法，这里时间设置稍长以确保数据能完整接收
    timer_ = this->create_wall_timer(10ms, [this] { readSerial(); });
}



SerialPortNode::~SerialPortNode() {
    sp_.flush();
    
    if (sp_.isOpen()) {
        sp_.close(); // 确保关闭串口
        gngga_data.clear();
        gnggah_data.clear();
    }
}


void SerialPortNode::processGpsData() {
    // 当两个队列中都至少有一个元素时，进行处理
    // 使用双端队列作为缓存
    std::cout << "正在处理GPS数据..." << std::endl;
    std::cout << "GNGGA队列大小: " << gngga_data.size() << std::endl;
    std::cout << "GNGGAH队列大小: " << gnggah_data.size() << std::endl;
    if (!gngga_data.empty() && !gnggah_data.empty()) {
        GpsData data_gngga = gngga_data.front();
        GpsData data_gnggah = gnggah_data.front();

        double avg_latitude = (data_gngga.latitude + data_gnggah.latitude) / 2.0;
        double avg_longitude = (data_gngga.longitude + data_gnggah.longitude) / 2.0;

        rtk_msg.latitude = avg_latitude;
        rtk_msg.longitude = avg_longitude;

        std::cout << std::fixed << std::setprecision(9);
        std::cout << "Average latitude: " << avg_latitude << std::endl;
        std::cout << "Average longitude: " << avg_longitude << std::endl;

        // 清空缓存区
        gngga_data.clear();
        gnggah_data.clear();
    }
}


// 读串口数据
void SerialPortNode::readSerial() {
    if (sp_.available()) {                      // 如果串口存在数据
        std::vector<uint8_t> buffer;            // 创建 buffer 来接收
        buffer.resize(sp_.available());         // 确定 buffer 的大小
        sp_.read(buffer, buffer.size());        // 读取当前 buffer

        // bool found_gngga = false;  // 用于标记是否找到了"$GNGGA,"

        for (auto byte : buffer) {              // 字节形式读数据到 serial_buffer_
            if (byte != 0)
                serial_buffer_ += byte;

            std::size_t end_line_pos = serial_buffer_.find("\r\n");     // 确定一个 end_line_pos 在 \r\n 之前
            while (end_line_pos != std::string::npos) {                 // end_line_pos 不等于 npos (存在)
                std::string line = serial_buffer_.substr(0, end_line_pos);// 将数据读入 字符串 line 中
                std::cout << "接收到的数据行: " << line << std::endl;
                serial_buffer_.erase(0, end_line_pos + 4);              // 清除 读过的 数据 + \r\n


                // 信息处理与发布
                SerialPortNode::processGpsData();
                m_rtk_pub->publish(rtk_msg);


                // 处理粘连的数据行
                std::size_t start_pos = 0;
                std::size_t ast_pos = line.find('*');                   // 确定一个 ast_pos 在 * 之前
                while (ast_pos != std::string::npos) {                  // ast_pos 不等于 npos (存在)
                    std::cout << "处理粘连数据……" << std::endl;
                    if (ast_pos + 3 <= line.length()) { // 确保有足够的字符来包含校验和
                        std::string message = line.substr(start_pos, ast_pos + 5 - start_pos);
                        processNmeaMessage(message); // 用于解析单条 NMEA 消息的函数
                        start_pos = ast_pos + 5;
                        ast_pos = line.find('*', start_pos);
                    } else {
                        // 如果没有足够的字符来包含校验和，跳出循环
                        break;
                    }
                }
                // 如果剩余部分是完整的 NMEA 消息，则处理它
                // if (line.front() == '$' && line.back() == '\n') {
                //     std::cout << "我进来了" << std::endl;
                //     processNmeaMessage(line);
                // }

                // 继续查找下一个数据行
                end_line_pos = serial_buffer_.find('\r');
            }
        }
    }
}


// 度分秒转十进制
double SerialPortNode::convertDmToDd(const std::string& dm)
{
    std::cout << "开始转换数据……" << std::endl;
    size_t dot_pos = dm.find('.');
    if (dot_pos != std::string::npos && dot_pos > 2) {
        double degrees = std::stod(dm.substr(0, dot_pos - 2));
        double minutes = std::stod(dm.substr(dot_pos - 2));
        std::cout << "转换成功" << std::endl; 
        return degrees + (minutes / 60.0);
    } else {
        throw std::runtime_error("Invalid DM format");
    }  
     
}


// rtk 数据行处理
void SerialPortNode::processNmeaMessage(const std::string& message) {

    std::cout << "开始数据处理……" << std::endl;
    // 分割数据行
    std::vector<std::string> tokens;
    std::stringstream ss(message);
    std::string token;
    while (std::getline(ss, token, ',')) {
        tokens.push_back(token);
    }

    // 解析GNGGA和GNGGAH数据
    if (tokens.size() >= 5) {
        std::cout << "接收一次数据，开始判断" << std::endl;
        try {
            if (tokens[0] == "$GNGGA" /* && sizeof(tokens[0]) == 6 */) {
                std::cout << "找到 GNGGA 数据" << std::endl;
                std::cout << tokens[0] << std::endl;
                GpsData data{};
                data.latitude = convertDmToDd(tokens[2]);
                data.longitude = convertDmToDd(tokens[4]);
                gngga_data.push_back(data);
            } else if (tokens[0] == "$GNGGAH" /* && sizeof(tokens[0]) == 7 */) {
                std::cout << "找到 GNGGAH 数据" << std::endl;
                std::cout << tokens[0] << std::endl;
                GpsData data{};
                data.latitude = convertDmToDd(tokens[2]);
                data.longitude = convertDmToDd(tokens[4]);
                gnggah_data.push_back(data);
            } else if (tokens[0] == "$GNTRA" /* && sizeof(tokens[0]) == 6 */) {
                std::cout << "找到 GNTRA 数据" << std::endl;
                rtk_msg.heading = 360.0 - std::stod(tokens[2]);
                // 输出第3行的第三个数据
                std::cout << std::fixed << std::setprecision(2);
                std::cout << rtk_msg.heading << std::endl;
                std::cout << tokens[2] << std::endl;
            }
        } catch (const std::exception& e) {
            std::cerr << "解析错误: " << e.what() << std::endl;
        }
    }
    tokens.clear();
    std::cout << "数据处理完毕……" << std::endl;
```

### 3、动作服务端处理 rtk.msg

```c++
/* 
    需求:编写动作通信服务端, 处理客户端提交的数据, 控制机器人运动至目标点, 并且连续反馈
        剩余距离, 最终还要响应机器人的停止坐标
    流程:
        1.创建动作通信服务端;
        2.处理请求数据,判断数据是否合法;
        3.处理客户端取消操作;
        4.生成连续反馈\生成最终响应;
 */

#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "my_exer_interfaces/action/nav.hpp"
#include "my_exer_interfaces/msg/rtgps.hpp"
// #include "geometry_msgs/msg/twist.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "sensor_msgs/msg/nav_sat_fix.hpp"
#include <transforms3d/transforms3d.h>
#include "sensor_msgs/msg/imu.hpp"
#include <GeographicLib/UTMUPS.hpp>
#include <cmath>
#include <string>
using namespace std::chrono_literals;
using my_exer_interfaces::action::Nav;
using std::placeholders::_1;
using std::placeholders::_2;
// 3.定义节点类；
class NavServer : public rclcpp::Node
{
public:
    NavServer(): Node("nav_server_node_cpp") , 
        // 私有参数初始值设置：
        northp(1), zone(0),
        theta_s(0.0),goal_latitude(0.0), goal_longitude(0.0), goal_theta(0.0),
        utm_x(0.0), utm_y(0.0), 
        goal_utm_x(0.0), goal_utm_y(0.0)
    {
        // 1.创建原生车辆位姿的定阅方，获取当前车辆的坐标       
        m_rtk_sub = this->create_subscription<my_exer_interfaces::msg::Rtgps>("rtkms", rclcpp::SensorDataQoS(), std::bind(&NavServer::rtk_cb, this, std::placeholders::_1));
        m_action_server = rclcpp_action::create_server<Nav>(
            this, 
            "nav",
            std::bind(&NavServer::handle_goal,this, _1, _2), // 2.处理请求数据,判断数据是否合法;
            std::bind(&NavServer::handle_cancel,this, _1),   // 3.处理客户端取消操作;
            std::bind(&NavServer::handle_accepted,this, _1)  // 4.生成连续反馈\生成最终响应;
        );

        m_parameters_client = std::make_shared<rclcpp::AsyncParametersClient>(this, "pub_vel_node_cpp");

        // 连接参数服务端
        while (!m_parameters_client->wait_for_service(1s))
        {
            if (!rclcpp::ok())
                return;
            RCLCPP_INFO(this->get_logger(), "服务连接中……");
        }
    }

private:
    // 参数初始值见类头==============》
    bool northp;
    int zone;
    double theta_s, goal_latitude, goal_longitude, goal_theta, utm_x, utm_y, goal_utm_x, goal_utm_y;
    
    rclcpp::AsyncParametersClient::SharedPtr                            m_parameters_client;
    rclcpp_action::Server<Nav>::SharedPtr                               m_action_server;
    // rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr m_cmd_pub;
    rclcpp::Subscription<my_exer_interfaces::msg::Rtgps>::SharedPtr     m_rtk_sub;
    my_exer_interfaces::msg::Rtgps                                      m_rtk_msg;
    
    void rtk_cb(const my_exer_interfaces::msg::Rtgps &msg) 
    {
        m_rtk_msg.heading   = msg.heading;
        m_rtk_msg.latitude  = msg.latitude;
        m_rtk_msg.longitude = msg.longitude;
        // using namespace GeographicLib;
        // 解算当前 UTM 坐标
        GeographicLib::UTMUPS::Forward(m_rtk_msg.latitude, m_rtk_msg.longitude, zone, northp, utm_x, utm_y);
        // RCLCPP_INFO(this->get_logger(), "这里是UTM坐标系: 纬度: %.8f, 经度：%.8f,x: %.3f, y: %.3f, 车辆当前航向角：%.2f ", m_rtk_msg.latitude, m_rtk_msg.longitude, utm_x, utm_y, m_rtk_msg.heading);
    }


    // 请求目标处理
    /* std::function<GoalResponse(
        const GoalUUID &, 
        std::shared_ptr<const typename ActionT::Goal>)>; 
    */
    rclcpp_action::GoalResponse handle_goal (
        const rclcpp_action::GoalUUID &uuid, 
        std::shared_ptr<const Nav::Goal> goal) 
    {
        (void)uuid;
        // (void)goal;
        // 取出目标中的 x y 坐标，分别判断是否超出了 [0, 11.08]取值，如果超出，则为非法，反之合法

        goal_latitude  = goal->goal_latitude;
        goal_longitude = goal->goal_longitude;

        // 将目标经纬度解析为UTM坐标系坐标
        GeographicLib::UTMUPS::Forward(goal_latitude, goal_longitude, zone, northp, goal_utm_x, goal_utm_y);

        // 判断给定坐标是否在取值范围内
        if (std::abs(goal_utm_x - utm_x) > 5 || std::abs(goal_utm_y - utm_y) > 5)
        {
            RCLCPP_ERROR(this->get_logger(), "目标点超出正常取值范围了！");
            return rclcpp_action::GoalResponse::REJECT;
        }
        
        RCLCPP_INFO(this->get_logger(), "目标符合要求！");
        return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
    }

    // 取消请求处理
    // std::function<CancelResponse(std::shared_ptr<ServerGoalHandle<ActionT>>)>;
    rclcpp_action::CancelResponse handle_cancel (std::shared_ptr<rclcpp_action::ServerGoalHandle<Nav>> goal_handle)
    {
        (void)goal_handle;
        RCLCPP_INFO(this->get_logger(), "任务取消！");
        return rclcpp_action::CancelResponse::ACCEPT;
    }

    /* 主逻辑处理 --------- 子线程单独实现*/
    void execute (std::shared_ptr<rclcpp_action::ServerGoalHandle<Nav>> goal_handle)
    {
        // 子线程处理主要逻辑
        RCLCPP_INFO(this->get_logger(), "主逻辑开始执行！");
        // 1.生成连续反馈
        auto result = std::make_shared<Nav::Result>();
        auto feedback = std::make_shared<Nav::Feedback>();
        // geometry_msgs::msg::Twist twist;
        rclcpp::Rate rate(50ms);
        while (rclcpp::ok())
        {
            // 如果客户端发送了取消请求，需要特殊处理
            if (goal_handle->is_canceling())
            {
                RCLCPP_INFO(this->get_logger(), "任务被取消！");
                result->x = utm_x;
                result->y = utm_y;
                // 设置取消后的最终结果
                goal_handle->canceled(result);
                return;
            }

            double goal_x = 0, goal_y = 0;
            // 将目标经纬度解析为UTM坐标系坐标
            GeographicLib::UTMUPS::Forward(goal_latitude, goal_longitude, zone, northp, goal_x, goal_y);
                
            // 计算剩余距离并发布
            float distance_x = goal_x - utm_x;
            float distance_y = goal_y - utm_y;
            float distance = sqrt(distance_x * distance_x + distance_y * distance_y);
            feedback->distance = distance;
            goal_handle->publish_feedback(feedback);
     
            // 获取目标点相对于车辆位置的方向角
            float targetHeading = std::atan2(distance_y, distance_x);

            // 当前航向角转弧度制
            double radians = m_rtk_msg.heading;
            double theta = (radians) * M_PI / 180.0;  // 角度转弧度

            if (theta >= 0 && theta < (M_PI_2 + M_PI))         // 将 rtk 的弧度与 atan2生成的 目标航向角统一坐标系
                theta +=  M_PI_2;
            else 
                theta -= M_PI_2 + M_PI;
            
            theta_s = theta; 

            if (theta_s > M_PI)
                theta_s -= 2*M_PI;
            
            // 待偏转角
            // 计算方向角之差
            float headingDiff = targetHeading - theta_s;   

            if (headingDiff > M_PI) {
                headingDiff -= 2 * M_PI;
            } else if (headingDiff <= -M_PI) {
                headingDiff += 2 * M_PI;
            }

            RCLCPP_INFO(this->get_logger(), "目标航向角：%.2f, 当前偏差角：%.2f, 自身航向角：%.2f", targetHeading, headingDiff, theta_s);
            // float scale_1 = 3;
            float scale_2 = 2;
            // float linear_x = scale_1 * std::abs(distance_x);
            // float linear_y = scale * distance_y;

            if (targetHeading <= 0.01)
                targetHeading = 0;
            // 线速度信息……
            m_parameters_client->set_parameters({rclcpp::Parameter("linear", 0.3), rclcpp::Parameter("angular",  scale_2 * headingDiff)});
            // twist.linear.x = linear_x;
            // twist.linear.y = linear_y;
            // 角速度信息……
            // twist.angular.z = scale_2 * headingDiff;
            // m_cmd_pub->publish(twist);
            // 循环结束条件
            if (distance <= 0.1)
            {
                // 乌龟的剩余距离与目标点的距离小于 0.05 米 就结束导航；
                RCLCPP_INFO(this->get_logger(), "车辆已经导航至目标点！");
                m_parameters_client->set_parameters({rclcpp::Parameter("linear", 0.0), rclcpp::Parameter("angular", 0.0)});
                break;
            } 
            
            rate.sleep();
        }
        // 3.生成最终响应结果
        if (rclcpp::ok())
        {
            result->x = m_rtk_msg.latitude;
            result->y = m_rtk_msg.latitude;
            result->theta = theta_s;
            goal_handle->succeed(result);
        }
    }

    // std::function<void (std::shared_ptr<ServerGoalHandle<ActionT>>)>;
    void handle_accepted (std::shared_ptr<rclcpp_action::ServerGoalHandle<Nav>> goal_handle)
    {
        // (void) goal_handle;
        // 小括号内封装执行体
        std::thread(std::bind(&NavServer::execute, this, goal_handle)).detach();
    }

};

int main(int argc, char const * argv[])
{
    // 2.初始化 ROS2 客户端；
    rclcpp::init(argc, argv);
    // 4.调用spin函数，并传入节点对象指针。
    rclcpp::spin(std::make_shared<NavServer>());
    // 5.释放资源；
    rclcpp::shutdown();
    return 0;
}
```

### 4、航点下发

这里选择在 launch 文件中用 python 给出列表数据，方便后期对接 app或小程序下发的 航点信息，这里第三列是航向数据，目前不做要求

```python
# 定义目标点的列表，这里使用浮点数组来表示经纬度和航向
    # 扁平化目标点数据为一个列表
    goals = [
        22.7049595, 114.2436170, 0.0,
        22.7049685, 114.2436249, 0.0,
        22.7049780, 114.2436329, 0.0,
        22.7049874, 114.2436411, 0.0,
        22.7049925, 114.2436340, 0.0,
        22.7049832, 114.2436257, 0.0,
        22.7049737, 114.2436170, 0.0,
        22.7049650, 114.2436098, 0.0,
        22.7049698, 114.2436031, 0.0,
        22.7049783, 114.2436095, 0.0,
        22.7049882, 114.2436179, 0.0,
        22.7049977, 114.2436270, 0.0,
        22.7050018, 114.2436212, 0.0,
        22.7049928, 114.2436121, 0.0,
        22.7049825, 114.2436032, 0.0,
        22.7049744, 114.2435964, 0.0
        # ...其他目标点数据...
    ]
```

在动作客户端将列表写入大小为3的元组 

```c++
this->declare_parameter<std::vector<double>>("goals", std::vector<double>());
std::vector<double> goals_param;
this->get_parameter("goals", goals_param);

if (goals_param.size() % 3 != 0) {
    RCLCPP_ERROR(this->get_logger(), "Goals参数应该可以被3整除（每个目标由经度、纬度和航向组成）");
    rclcpp::shutdown();
    return;
}


for (size_t i = 0; i < goals_param.size(); i += 3) {
    goals_.emplace_back(std::make_tuple(goals_param[i], goals_param[i + 1], goals_param[i + 2]));
}



RCLCPP_INFO(this->get_logger(), "动作客户端被创建了！准备发送目标点。");
//1.创建动作客户端
m_client = rclcpp_action::create_client<Nav>(this,"nav");
// 发送第一个目标
if (!goals_.empty()) {
    send_goal_to_server();
}


// 新增方法发送目标给服务器
void send_goal_to_server() {
    auto [goal_latitude, goal_longitude, goal_theta] = goals_[current_goal_index_];
    send_goal(goal_latitude, goal_longitude, goal_theta);
}

// 使用current_goal_index_来跟踪已经发送的下一个目标点的索引。通过对goals_大小取余，它实现了在目标列表中循环。当完成最后一个目标后，此操作使索引重新开始。
current_goal_index_ = (current_goal_index_ + 1) % goals_.size(); // loop back to start

```

这里是动作客户端代码：

```c++
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "my_exer_interfaces/action/nav.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "sensor_msgs/msg/imu.hpp"
#include <cmath>
using namespace std::chrono_literals;
using my_exer_interfaces::action::Nav;
using std::placeholders::_1;
using std::placeholders::_2;


// 3.定义节点类；
class NavClient : public rclcpp::Node
{
public:
    NavClient(): Node("nav_client_node_cpp"), current_goal_index_(0) {
        RCLCPP_INFO(this->get_logger(), "动作客户端被创建了！");
        // 这行代码声明了一个名为"goals"的参数，默认值为空的std::vector<double>。这使得节点知道它期望有一个名为"goals"的参数。
        this->declare_parameter<std::vector<double>>("goals", std::vector<double>());       
        // 创建一个std::vector<double>类型的变量goals_param，用来存储"goals"参数的值。
        std::vector<double> goals_param;
        // 这行代码实际上从参数服务器中获取名为"goals"的参数，并将其值赋给goals_param变量。
        this->get_parameter("goals", goals_param);
        // 这是一个检查，确保goals_param的大小能被3整除。因为每个目标点包含三个值（一般是经度、纬度和航向），如果不能被3整除，则参数格式不正确。
        if (goals_param.size() % 3 != 0) {
            RCLCPP_ERROR(this->get_logger(), "Goals参数应该可以被3整除（每个目标由经度、纬度和航向组成）");
            rclcpp::shutdown();
            return;
        }
        // 如果参数格式正确，这个循环将遍历goals_param，每三个元素创建一个元组，并将其添加到goals_向量中。
        for (size_t i = 0; i < goals_param.size(); i += 3) {
            goals_.emplace_back(std::make_tuple(goals_param[i], goals_param[i + 1], goals_param[i + 2]));
        }

        RCLCPP_INFO(this->get_logger(), "动作客户端被创建了！准备发送目标点。");
        //1.创建动作客户端
        m_client = rclcpp_action::create_client<Nav>(this,"nav");
        // 发送第一个目标
        if (!goals_.empty()) {
            send_goal_to_server();
        }
    }
    //2.连接服务端,发送请求
    void send_goal(double goal_latitude, double goal_longitude, double goal_theta)
    {
        (void)goal_theta;
        // 连接服务端
        if (!m_client->wait_for_action_server(5s))
        {
            RCLCPP_INFO(this->get_logger(), "连接服务器失败！已超时！");
            return;
        }
        // 组织并发送数据
        Nav::Goal goal;
        goal.goal_latitude = goal_latitude;
        goal.goal_longitude = goal_longitude;
        goal.goal_theta    = goal_theta;
        rclcpp_action::Client<Nav>::SendGoalOptions options;

        // std::function<void (std::shared_ptr<rclcpp_action::ClientGoalHandle<base_interfaces_demo::action::Nav>>)
        options.goal_response_callback = std::bind(&NavClient::goal_response_callback, this, _1);
        
        // std::function<void (
            // std::shared_ptr<rclcpp_action::ClientGoalHandle<base_interfaces_demo::action::Nav>>, 
            // std::shared_ptr<const base_interfaces_demo::action::Nav_Feedback>)
        options.feedback_callback = std::bind(&NavClient::feedback_callback, this, _1, _2);
        
        // std::function<void (const rclcpp_action::ClientGoalHandle<base_interfaces_demo::action::Nav>::WrappedResult &result)
        options.result_callback = std::bind(&NavClient::result_callback, this, _1);;
        
        m_client->async_send_goal(goal, options);
    }

    void cancel(rclcpp_action::ClientGoalHandle<Nav>::SharedPtr goal_handle){
        // 当 rclcpp::ok() 返回 False 时，取消任务
        while (rclcpp::ok()){}
        m_client -> async_cancel_goal(goal_handle);

    }


    //3.处理目标值相关的响应结果
    void goal_response_callback (std::shared_ptr<rclcpp_action::ClientGoalHandle<Nav>> goal_handle)
    {
        if (!goal_handle) {
            RCLCPP_INFO(this->get_logger(), "请求目标非法");
            return;
        }
        else
            RCLCPP_INFO(this->get_logger(), "请求目标合法");
        // 单独一根线程，循环判断终端状态
        std::thread{std::bind(&NavClient::cancel,this,_1),goal_handle}.detach();
    }


    //4.处理连续反馈和最终响应的结果
    void feedback_callback (std::shared_ptr<rclcpp_action::ClientGoalHandle<Nav>> goal_handle, std::shared_ptr<const Nav::Feedback> feedback)
    {
        (void)goal_handle;
        RCLCPP_INFO(this->get_logger(), "剩余%.2f米", feedback->distance);
    }
    
    //5.处理最终反应
    // void result_callback (const rclcpp_action::ClientGoalHandle<Nav>::WrappedResult &result)
    // {
    //     if (result.code == rclcpp_action::ResultCode::SUCCEEDED) {
    //         RCLCPP_INFO(this->get_logger(), "车辆位姿信息：坐标(%.2f, %.2f), 航向：%.2f", result.result->x, result.result->y, result.result->theta);
    //     } else {
    //         RCLCPP_ERROR(this->get_logger(), "响应失败！");
    //     }
    // }


    // 5.修改result_callback以在成功后发送下一个目标
    void result_callback(const rclcpp_action::ClientGoalHandle<Nav>::WrappedResult &result) {
        if (result.code == rclcpp_action::ResultCode::SUCCEEDED) {
            RCLCPP_INFO(this->get_logger(), "成功到达目标点");
            RCLCPP_INFO(this->get_logger(), "车辆位姿信息：坐标(%.2f, %.2f), 航向：%.2f", result.result->x, result.result->y, result.result->theta);

            // 使用current_goal_index_来跟踪已经发送的下一个目标点的索引。通过对goals_大小取余，它实现了在目标列表中循环。当完成最后一个目标后，此操作使索引重新开始。
            current_goal_index_ = (current_goal_index_ + 1) % goals_.size(); // loop back to start
            send_goal_to_server();
        } else {
            RCLCPP_ERROR(this->get_logger(), "无法到达目标点");
            // Optional: decide if you want to try the current goal again, or move to next
        }
    }


private:
    rclcpp_action::Client<Nav>::SharedPtr m_client;
    std::vector<std::tuple<double, double, double>> goals_;
    size_t current_goal_index_;


    // 新增方法发送目标给服务器
    void send_goal_to_server() {
        auto [goal_latitude, goal_longitude, goal_theta] = goals_[current_goal_index_];
        send_goal(goal_latitude, goal_longitude, goal_theta);
    }
};


int main(int argc, char const * argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<NavClient>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

