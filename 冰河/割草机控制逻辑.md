# 关于割草机控制逻辑的简要说明

## 一、下位机

### 1.电机控制信号的确定

示波器测得 P W M 周期为 14 ms   为71.4286 Hz

所以有：

```c++
#ifndef PWM_CONTROL__H
#define PWM_CONTROL__H


#include <Arduino.h>
/* =============================== */
#include "driver/mcpwm.h"


// 定义MCPWM单元和定时器
#define MCPWM_UNIT  MCPWM_UNIT_0
#define MCPWM_TIMER MCPWM_TIMER_0

const float wheel_distance_ = 0.76;

class Pwm_control
{
public:

    Pwm_control(); // 构造函数
    ~Pwm_control(); // 析构函数
    void  botPwm_init() const;
    float mapFloat(int x, float in_min, float in_max, float out_min, float out_max);
    float getDutyCycle(int speed);
    void  set_WheelSpeed(double linear_speed, double angular_speed);
    // 定义GPIO引脚
    const int r_pwmPin = 4;                   // 用于MCPWM的GPIO，右轮
    const int l_pwmPin = 5;                   // 用于MCPWM的GPIO，左轮
    // 设置的PWM频率
    const float pwmFrequency = 71.4286;       // 71.4286 Hz
    // 占空比控制区间
    const float dutyCycleMinCCW = 8.857;    // 逆时针最小占空比
    const float dutyCycleMaxCCW = 10.639;   // 逆时针最大占空比
    const float dutyCycleMinCW  = 10.639;   // 顺时针最小占空比
    const float dutyCycleMaxCW  = 12.429;   // 顺时针最大占空比
private:
};



#endif /* PWM_CONTROL__H */
```

### 2、电机占空比的精细控制，

此处代码定义了在不同区间段的 电机转向逻辑，值得注意的是，10.639 是测量中间值，当占空比小于 此中间值时，占空比越小，电机逆时针转速越快，当占空比大于此中间值时，占空比越大，电机顺时针转速越快。关于 P W M 控制 采用了 arduino框架 内置的 mcpwm库。

```c++
/**
 * 此函数初始化MCPWM的每个gpio信号
 * 参数: mcpwm_num-设置MCPWM单元 (0-1) io_signal-设置MCPWM信号，每个MCPWM单元有6个输出 (MCPWMXA，MCPWMXB) 和9个输入 (同步_X，故障_X, CAP_X) 'X' 是计时器_num(0-2) gpio_num-设置此为MCPWM配置gpio，如果要使用gpio16，gpio_num = 16
 * 返回: ESP_OK成功-ESP_ERR_INVALID_ARG参数错误
 * 备注: 此函数一次初始化一个gpio。
 * 
 */
void  Pwm_control::botPwm_init() const
{
    // 初始化两个电机的引脚
    mcpwm_gpio_init(MCPWM_UNIT, MCPWM0A, this->l_pwmPin);
    mcpwm_gpio_init(MCPWM_UNIT, MCPWM0B, this->r_pwmPin);
    pwmConfig.frequency = this->pwmFrequency;     // 初始化MCPWM配置
    pwmConfig.cmpr_a = 0;
    pwmConfig.cmpr_b = 0;
    pwmConfig.counter_mode = MCPWM_UP_COUNTER;
    pwmConfig.duty_mode = MCPWM_DUTY_MODE_0;
    mcpwm_init(MCPWM_UNIT, MCPWM_TIMER, &pwmConfig);  // 设置并启动MCPWM
}
```

将两个占空比区间各分250个分辨率，初始假定割草机最大行进速度为1 m/s

```c++
// 映射浮点数的函数
//   (x/250) * (10.639-8.857)    相当于将占空比分出 250 份中取 x 份

float Pwm_control::mapFloat(int x, float in_min, float in_max, float out_min, float out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
```

### 3、电机转向逻辑匹配

下面根据上位机给出的线速度与角速度输出对应的差速指令

```c++
/**
 * @参数   线速度，角速度
 * @输出   无
  */
void Pwm_control::set_WheelSpeed(const double linear_speed, const double angular_speed)
{
    // 计算左轮的转速 out_wheelL_speed，公式为 线速度 减去 角速度乘以轮距的一半
    double out_wheelL_speed =
        linear_speed - (angular_speed * wheel_distance_) / 2.0;
    // 计算右轮的转速 out_wheelR_speed，公式为 线速度 加上 角速度乘以轮距的一半。
    double out_wheelR_speed =
        linear_speed + (angular_speed * wheel_distance_) / 2.0;

    // 这里不做最大速度限制，但原则上说下位机控制板应该监控轮速并且在轮速异常时与上位机确认，给出一个绝对控制 IO 作为安全保障
    if (linear_speed == 0 && angular_speed == 0)
    {
        double dutyCycle1 = this->getDutyCycle(250);
        if (dutyCycle1 >= 0) {
            // 设置占空比
            mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, dutyCycle1);
            mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, MCPWM_DUTY_MODE_0);
        }
        double dutyCycle2 = this->getDutyCycle(250);
        if (dutyCycle2 >= 0) {
            // 设置占空比
            mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, dutyCycle2);
            mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, MCPWM_DUTY_MODE_0);
        }
        return;
    }

    // 这里判断 输出轮速对应 250 个分辨率中的位置
    // 考虑做四舍五入处理  round(value)

    int speed1 = 0;
    float dutyCycle1 = 0.0;
    int speed2 = 0;
    float dutyCycle2 = 0.0;
    // 左轮
    if (out_wheelL_speed > 0) {                 // 左轮顺时针
        speed1 = round(250 - (out_wheelL_speed * 250));
        if (speed1 <= 0)
            speed1 = 0;

        dutyCycle1 = this->getDutyCycle(speed1);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, dutyCycle1);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, MCPWM_DUTY_MODE_0);
    } else if (out_wheelL_speed < 0) {          // 左轮逆时针
        speed1 = round(250 + std::abs(out_wheelL_speed * 250));
        if (speed1 >= 500)
            speed1 = 500;

        dutyCycle1 = this->getDutyCycle(speed1);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, dutyCycle1);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_A, MCPWM_DUTY_MODE_0);
    }

    if (out_wheelR_speed > 0) {                 // 右轮顺时针
        speed2 = round(250 + (out_wheelR_speed * 250));
        if (speed2 >= 500)
            speed2 = 500;

        dutyCycle2 = this->getDutyCycle(speed2);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, dutyCycle2);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, MCPWM_DUTY_MODE_0);
    } else if (out_wheelR_speed < 0) {          // 右轮逆时针
        speed2 = round(250 - std::abs(out_wheelR_speed * 250));
        if (speed2 <= 0)
            speed2 = 0;
        dutyCycle2 = this->getDutyCycle(speed2);
        mcpwm_set_duty(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, dutyCycle2);
        mcpwm_set_duty_type(MCPWM_UNIT, MCPWM_TIMER, MCPWM_GEN_B, MCPWM_DUTY_MODE_0);
    }

}

```

## 二、上位机

### 1、创建动作消息接口和RTK设备串口信息接收接口

动作消息接口.action

```apl
# 请求数据
float64 goal_theta
float64 goal_latitude
float64 goal_longitude
---
# 最终响应
float64 x
float64 y
float64 theta
---
# 连续反馈
float64 distance
```

RTK数据消息接口.msg

```apl
# Rtgps.msg
float64 heading
float64 latitude
float64 longitude
```

### 2、利用 ROS2 串口库对 rtk设备信息进行处理并发布对应的 <RTK数据消息接口.msg>

