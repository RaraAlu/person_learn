#### Git SSH --- [nmea_navsat_driver](https://github.com/ros-drivers/nmea_navsat_driver) 学习

```shell
git clone git@github.com:ros-drivers/nmea_navsat_driver.git -b ros2 克隆该功能包下 ros2分支

>更改----》
/home/ls/ls/BHROS/gps_ws/src/nmea_navsat_driver/config/nmea_serial_driver.yaml
==================================================================================
nmea_navsat_driver:
  ros__parameters:
    port: "/dev/ttyUSB0"
    baud: 115200
    frame_id: "gps"
    time_ref_source: "gps"
    useRMC: False
>更改----》
/home/ls/ls/BHROS/gps_ws/src/nmea_navsat_driver/src/libnmea_navsat_driver/nodes/nmea_serial_driver.py
======================================================================================================
46    serial_port = driver.declare_parameter('port', '/dev/ttyUSB0').value
47    serial_baud = driver.declare_parameter('baud', 115200).value

回到工作工作空间目录下，colcon build --packages-select (b)
```



#### Git SSH --- **[rviz_satellite](https://github.com/nobleo/rviz_satellite)** 学习

```
git clone git@github.com:nobleo/rviz_satellite.git -b ros2

ros2 launch rviz_satellite demo.launch.xml
```

#### Git SSH --- **[robot_localization](https://github.com/cra-ros-pkg/robot_localization)**学习

```shell
git clone git@github.com:cra-ros-pkg/robot_localization.git -b humble-devel


```

#### rviz2 地图

```shell
sudo apt-get install ros-humble-mapviz
```

#### 这是一个从串口读RTK数据的函数

```c++
void SerialPortNode::readSerial() {
    // 每次调用函数时，重置gngga_encountered标志
    bool gngga_encountered = false;

    if (sp_.available()) {
        std::vector<uint8_t> buffer;
        // 读取数据
        buffer.resize(sp_.available());
        sp_.read(buffer, buffer.size());
    
        // 累积数据直到我们找到 \r\n
        for (auto byte : buffer) {                               // 遍历缓冲区中的每个字节。           
            
            if (byte == bit && !serial_buffer_.empty()) {
                // 当遇到新的'$'时，清除之前的数据
                serial_buffer_.clear();
            }
            
            // 无论什么时候遇到'$'，都开始填充缓冲区
            if (byte == bit || !serial_buffer_.empty()) {
                serial_buffer_ += byte;                          // 将当前字节添加到字符串 serial_buffer_中。
            }

            std::size_t pos = serial_buffer_.find("\r\n");       // 查找字符串 serial_buffer_中第一个"\r\n"的位置。

            if (pos != std::string::npos) {                      // 如果找到了

                // 提取一行，不包含 \r\n
                tokens.clear(); // 在解析新行之前清空tokens
                std::string line = serial_buffer_.substr(0, pos);
                std::stringstream ss(line);
                std::string token;
                
                while (std::getline(ss, token, ',')) { // 使用逗号作为分隔符
                    tokens.push_back(token); // 将分割后的数据存入数组中
                }

                // 检查是否是GNGGA数据
                if (tokens[0].find("GNGGA") != std::string::npos && tokens.size() > 5) {
                    gngga_encountered = true; // 设置标志为true
                    // 输出GNGGA行的第三个数据和第五个数据
                    std::cout << tokens[2] << ", " << tokens[4] << std::endl;
                } else if (gngga_encountered) {
                    // 如果已经遇到GNGGA数据，那么开始输出其他行的特定数据
                    if (tokens[0].find("GNGGAH") != std::string::npos && tokens.size() > 5) {
                        // 输出GNGGAH行的第三个数据和第五个数据
                        std::cout << tokens[2] << ", " << tokens[4] << std::endl;
                    } else if (tokens[0].find("GNTRA") != std::string::npos && tokens.size() > 2) {
                        // 输出GNTRA行的第三个数据
                        std::cout << tokens[2] << std::endl;
                    }
                }

                // 清除包含 \r\n 的行
                serial_buffer_.erase(0, pos + 2);                 
            }
        }
    }
}

```

