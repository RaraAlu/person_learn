#### 模板

```c++
#include <iostream>

int main() {
    
    return 0;
}
```

#### 串口数据获取与解析

```cmake
cmake_minimum_required(VERSION 3.8)
project(Gphpr_pub)


if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()


list(APPEND CMAKE_PREFIX_PATH "/tmp/usr/local")


# find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(my_exer_interfaces REQUIRED)
find_package(serial REQUIRED)

add_executable(gphpr_node src/gphpr_node.cpp)
target_include_directories(gphpr_node PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>)
target_compile_features(gphpr_node PUBLIC c_std_99 cxx_std_17)  # Require C99 and C++17
ament_target_dependencies(
  gphpr_node
  "rclcpp"
  "my_exer_interfaces"
  "serial"
)

install(TARGETS gphpr_node
  DESTINATION lib/${PROJECT_NAME})

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # comment the line when a copyright and license is added to all source files
  set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # comment the line when this package is in a git repo and when
  # a copyright and license is added to all source files
  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()
```

```c++
#include <atomic>
#include <chrono>
#include <cmath>
#include "serial/serial.h"
#include <rclcpp/rclcpp.hpp>
#include "my_exer_interfaces/msg/rtgps.hpp"
#include <vector>
#include <string>
#include <sstream>
#include <thread>

// 全局原子变量，用于控制线程执行
std::atomic_bool imu_thread_running(false);
std::atomic_bool imu_data_ready(false);

// 自定义ROS 2节点
class RtgpsDriverNode : public rclcpp::Node {
public:
    RtgpsDriverNode() : Node("rtgps_driver_node"), _port_name("/dev/ttyUSB0") {
        // 初始化发布者
        publisher_ = this->create_publisher<my_exer_interfaces::msg::Rtgps>("Rtgps_msg", 10);
        // 启动串口读取线程
        imu_thread_running = true;
        imu_thread_ = std::thread(&RtgpsDriverNode::readSerialData, this);
    }

    ~RtgpsDriverNode() {
        imu_thread_running = false;
        if (imu_thread_.joinable()) {
            imu_thread_.join();
        }
    }

private:
    rclcpp::Publisher<my_exer_interfaces::msg::Rtgps>::SharedPtr publisher_;
    std::thread imu_thread_;
    std::string _port_name;

    void readSerialData() {
        serial::Serial rtgps_serial(_port_name, 460800, serial::Timeout::simpleTimeout(1000));
        try {
            rtgps_serial.open();
        } catch (const serial::IOException& e) {
            RCLCPP_ERROR(this->get_logger(), "无法打开串口: %s", e.what());
            return;
        }

        if (rtgps_serial.isOpen()) {
            RCLCPP_INFO(this->get_logger(), "串口初始化成功");
        } else {
            RCLCPP_ERROR(this->get_logger(), "串口未打开");
            return;
        }

        while (imu_thread_running && rtgps_serial.isOpen()) {
            if (rtgps_serial.available()) {
                std::string line;
                rtgps_serial.readline(sizeof(rtgps_serial), line);
                if (!line.empty()) {
                    my_exer_interfaces::msg::Rtgps rtgps_message = parseRtgpsData(line);
                    publisher_->publish(rtgps_message);
                }
            }
        }
    }

    my_exer_interfaces::msg::Rtgps parseRtgpsData(const std::string& data_sentence) {
        my_exer_interfaces::msg::Rtgps msg;
        std::string temp;
        std::istringstream ss(data_sentence);
        
        try {
            std::getline(ss, temp, ','); // 跳过 #UNIHEADINGA
            std::getline(ss, temp, ','); // 周数
            msg.week = std::stoi(temp);
            std::getline(ss, temp, ','); // 标题序列
            msg.heading_sequence = temp;
            std::getline(ss, temp, ','); // GPS状态
            msg.gps_status = temp;
            std::getline(ss, temp, ','); // 解状态
            msg.sol_status = temp;
            std::getline(ss, temp, ','); // 周内时间
            msg.tow = std::stoi(temp);
            std::getline(ss, temp, ','); // 航向
            msg.heading = std::stod(temp);
            std::getline(ss, temp, ','); // 俯仰
            msg.pitch = std::stod(temp);
            std::getline(ss, temp, ','); // 横滚
            msg.roll = std::stod(temp);
            std::getline(ss, temp, ','); // 陀螺偏置
            msg.gyro_bias = std::stod(temp);
            std::getline(ss, temp, ','); // 陀螺比例
            msg.gyro_scale = std::stod(temp);
            // 根据需要解析剩余字段
            // ...
            size_t star_pos = data_sentence.find('*');
            if (star_pos != std::string::npos) {
                msg.crc = data_sentence.substr(star_pos + 1, 4); // 获取CRC值
            }
        } catch (const std::invalid_argument& e) {
            RCLCPP_ERROR(this->get_logger(), "解析Rtgps数据失败: %s", e.what());
        } catch (const std::out_of_range& e) {
            RCLCPP_ERROR(this->get_logger(), "解析值超出范围: %s", e.what());
        }
        
        return msg;
    }
};

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<RtgpsDriverNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

